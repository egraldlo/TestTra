0，ID为0的进程通常是调度进程，常常被称为swapper，ID为1的进程通常是init进程，在自举过程中被内核调用，init通常读与系统相关的初始化文件(/etc/rc*,/etc/inittab,/etc/init.d)，并将系统引导到一个状态，例如多用户，
  进程init绝对不会终止。它是一个普通的用户进程，但是又不是和swapper一样的内核中的系统进程。他以超级用户的权限运行，是所有孤儿进程的父进程。

1, 父进程为0的进程通常是内核进程，他们在系统自举的时候启动。比如init,但是init不是
内核进程，是用户层命令。init进程号通常是1

2, cron守护进程在指定的日期和时间执行指定的命令，大多数守护进程都是以超级用户的特权运行。
他们均没有终端控制权

3， 只有处于active的进程能够获取控制台的输入，并且signal只是发送给active内的进程，
当用户按下 Ctrl-C 或者 Ctrl-Z 的时候，只有前台的进程会收到相应的信号，并执行相应的操作。

4， 当登录一个控制终端的时候，这时相当于有了一个叫bash的进程，当输入一行命令的时候，这时候bash就会
建一个进程组，为什么是一个进程组而不是一个进程呢？可以做一下实验：
在bash中输入：cat & 
（也就是创建一个cat的进程组在后台运行，通过ps -o pid,pgid,ppid,sid,tty,comm可以看见具体的情况）
但是在bash中如果输入的是：cat|cat &
（也就是创建通过管道连接的两个cat进程所构成的进程组，通过ps -o pid,pgid,ppid,sid,tty,comm查看，我们
可以看见里面两个cat进程的进程号是不同的，但是其中有一个进程号和进程组号是一样的，这个和进程组号相同的进程号
就是组长进程，所以可以证明bash的一条命令创建的是一个进程组而不是一个进程，不要因为你输入的是一条“单”语句而
迷惑自己，试试在命令之间加上“|”）

在上面的两个实验中，有个SID，这个是会话号（session id），这个会话号是你开始登录这个控制终端的时候所建的进
程的进程号，session 是由 login (ssh/getty/…) 程序创建的，bash 仅仅是继承了这个 session。如果你继续
新建后台进程，你可以发现的是ps -o pid,pgid,ppid,sid,tty,comm这个命令显示的进程的会话号都是一样的。说
明了一个控制终端是对应一个会话的，我直接kill sid，这个bash窗口就直接弹出了

问题：
但是ps -aux为什么会显示不同的终端呢？

5，终端
终端：终端是指你的电脑显示屏和你的键盘，这些“硬件终端设备”
虚拟终端：虚拟终端指的是ctrl+alt+F[2-6]弹出的这些终端，是虚拟出的6个终端
伪终端：伪终端就是你图形界面上建的终端，伪终端没有个数限制
控制终端：你当前所处的终端，是个逻辑概念

问题：
tty和pty有什么区别？

6，信号机制？
前台进程组，后台进程组和active进程组和unactive进程组的区别？

